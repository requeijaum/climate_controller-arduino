/*
struct SensorData {
   uint8_t    Auto;   //array de caracteres tá bugado (usar strcpy())... mas no fancoil.HEC usarei apenas "int"
   uint8_t    Busy;
   uint8_t    Pres;
   uint8_t    Status;
   uint8_t    tTrigger;
   uint8_t    tMin;
   uint8_t    tAtual;
   uint8_t    tMax;
   
};

struct ProgramaHorario { //Auto, Busy, e Status... você acessa "struct SensorData"... 
                         //precisamos economizar memória
  unsigned char    pd1[5];
  unsigned char    pd2[5];
  unsigned char    pl1[5];
  unsigned char    pl2[5]; 
  
  uint8_t             mask;
  uint8_t             domingo;
  uint8_t             segunda;
  uint8_t             terca;
  uint8_t             quarta;
  uint8_t             quinta;
  uint8_t             sexta;
  uint8_t             sabado;        
  
};

struct SensorData                  data;   //no rev4_2 era "msg"
struct ProgramaHorario             prog;



//--------------------------------------------------------------------------------------------------------------


void serialize(const SensorData& data, char* json, size_t maxSize, char* copy)
{
    StaticJsonBuffer<JSONOBJECT_JSON_SIZE> jsonBuffer;      //preciso mudar o tamanho a depender do JSON
    JsonObject& root = jsonBuffer.createObject();           //ou a depender de "int data.Status"

        root["a"]   = data.Auto;
        root["b"]   = data.Busy;
        root["m"]   = prog.mask;
        root["p"]   = data.Pres;
        root["pd1"] = prog.pd1;
        root["pd2"] = prog.pd2;
        root["pl1"] = prog.pl1;
        root["pl2"] = prog.pl2;
        root["s"]   = data.Status;
        root["t1"]  = data.tMin;
        root["t2"]  = data.tAtual;
        root["t3"]  = data.tMax;
        root["tt"]  = data.tTrigger;

    root.printTo(json,  maxSize);
    memcpy(copy , json, maxSize);
    delay(DELAY_MS);
    return;
}



void deserialize(SensorData& data, char* json)
{
    StaticJsonBuffer<JSONOBJECT_JSON_SIZE> jsonBuffer;
    JsonObject& root = jsonBuffer.parseObject(json);
   

    if (!root.success()) {
      //Serial.println("parseObject() failed");
      return;
    }
    
    if (root.success()) {
      //Serial.println("parseObject() successful");

     //previne sobrescrever valores na estrutura "nulos ou zeros", 
     //caso não tenha recebido um JSON válido
         //String bfr;
         if (root.containsKey("a")) {
          data.Auto      = root["a"];
         }

         if (root.containsKey("b")) {
          data.Busy      = root["b"]; 
         }

         if (root.containsKey("m")){
          prog.mask      = root["m"]; 
         }

         if (root.containsKey("p")) {
          data.Pres      = root["p"];
         }

         if (root.containsKey("pd1")) {
          prog.pd1       = root["pd1"];
          //bfr = root["pd1"];
          //bfr.toCharArray(bfr,4);
         }

         if (root.containsKey("pd2")){
          prog.pd2       = root["pd2"];
          //bfr = root["pd2"];
          //bfr.toCharArray(bfr,4);
         }

         if (root.containsKey("pl1")) {
          prog.pl1       = root["pl1"];
          //bfr = root["pl1"];
          //bfr.toCharArray(bfr,4);
         }

         if (root.containsKey("pl2")) {
          prog.pl2       = root["pl2"];
          //bfr = root["pl2"];
          //bfr.toCharArray(bfr,4); 
         }

         if (root.containsKey("s")) {
          data.Status    = root["s"]; 
         }

         if (root.containsKey("t1")){
          data.tMin      = root["t1"]; 
         }

         if (root.containsKey("t2")){
          data.tAtual    = root["t2"]; 
         }

         if (root.containsKey("t3")){
          data.tMax      = root["t3"]; 
         }

         if (root.containsKey("tt")){
          data.tTrigger  = root["tt"]; 
         }
         
     }
     
   delay(DELAY_MS);  
   return;
     
    }


//---------------------------------------------------------------------------------------------

void lerSerial(String texto, char* teste){
    //lê "String texto" vindo da "Serial" e copia para "char texto[JSON_OUT_SIZE]"
    //--> falta implementar anti-DDoS pela porta serial
    if(Serial.available() > 0) {
      //Serial.println(Serial.available());
      texto = Serial.readString();
      //texto = "aa";
      Serial.setTimeout(1000);  //in milliseconds - devo definir isso? evita um tipo de DDoS pela porta serial.
      //Serial.println(texto);
      texto.getBytes(teste, JSON_OUT_SIZE);
      //Serial.println(teste);    //não precisa imprimir o que recebeu - sem loopback/echo
    }  
}


void troca_status(){
    if ((data.Auto == 1) && (i == 2)) data.Status = 1; //tentar inverter ordem - caso dê bug
    if ((data.Auto == 0) && (i == 2)) data.Status = 0;   
  
}

void busy() {

    //posso usar um for?
    //separar i ... pra 3 bits diferentes?
    
    if (data.Busy == 1)  i++;
    
    if (i == 3) {
      data.Busy = 0;
      i = 0;
    }
    
  }

void checkbitmask(void) {

  //aí... agora vai?

  if ( (prog.mask & 1) ==   1 ) prog.segunda = 1;
  else prog.segunda = 0;

  if ( (prog.mask & 2) ==   2 ) prog.terca = 1;
  else prog.terca = 0;

  if ( (prog.mask & 4) ==   4 ) prog.quarta = 1;
  else prog.quarta = 0;

  if ( (prog.mask & 8) ==   8 ) prog.quinta = 1;
  else prog.quinta = 0;

  if ( (prog.mask & 16) == 16 ) prog.sexta = 1;
  else prog.sexta = 0;

  if ( (prog.mask & 32) == 32 ) prog.sabado = 1;
  else prog.sabado = 0;

  if ( (prog.mask & 64) == 64 ) prog.domingo = 1;
  else prog.domingo = 0;


}
*/